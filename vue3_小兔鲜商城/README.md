# Vue3_PC_小兔鲜商城项目

vue3.0、vue-cli (项目脚手架)、axios (请求接口)、vue-router (单页路由)、vuex (状态管理)、vuex-persistedstate (vuex 数据持久化)、normalize.css (初始化样式)、@vueuse/core (组合 api 常用工具库)、dayjs (日期处理)、vee-validate （表单校验）

算法 [Power Set](https://github.com/zhousg/javascript-algorithms/blob/master/src/algorithms/sets/power-set)

由于前台项目，没有合适的 UI 组件库（没有适用 vue3.0 的 ui 库），所有组件基本自己封装。

## 一. 准备阶段

1. vuex 设置
   - vuex 模块化 （方便后期维护）全局模块（不带命名空间）和局部模块（带命名空间 `namespaced: true`）
2. vuex 持久化
   - 目的：让在 vuex 中管理的状态数据同时存储在本地。可免去自己存储的环节。例如用户的信息（昵称 token 等）、在未登录状态下也可以加入购物车（存储购物车内容信息）
   - 安装 vuex 持久化插件`vuex-persistedstate`在 index.js 文件引入插件，默认导出中添加 plugins 属性，加入需要持久化的 vuex 信息模块即可。
3. 封装统一请求工具：基于**axios**封装一个请求工具，调用接口时使用。
   - 创建一个新的 axios 实例
   - 请求拦截器，如果有 token 进行头部携带
   - 响应拦截器：1. 剥离无效数据 2. 处理 token 失效(跳到登录页，清空用户信息)
   - 导出一个函数，调用当前的 axsio 实例发请求，返回值 promise
4. 路由设计
   - 路由级别：
     - 一级路由：首页布局容器、 登录、 第三方登录回调
     - 二级路由：首页、一级分类、 二级分类、 商品详情、 购物车、 填写订单、 进行支付、 支付结果、 个人中心布局容器
     - 三级路由： 个人中心、订单管理 、订单详情
   - 路由嵌套配置：一级路由在`src/App.vue`，在`src/views/layout/index.vue`中定义一级路由布局容器组件，在`src/views/Home/index.vue`定义二级路由首页组件
   - 配置路由规则：引入 createRouter 和 createWebHashHistory 从 vue-router 中
5. less 自动化引入
   - 目标：创建公共全局样式变量（比如背景颜色，文字大小，等等）每一次都需要单独引入，为了方便，使用 vue-cli 的 style-resoures-loader 插件来完成自动注入到每个 vue 组件中 style 标签中 `vue add style-resources-loader`
6. layout 组件布局
   - 头，身，尾布局，抽离公共组件（导航组件和吸顶组件有一部分是通用的）
   - 调接口获取头部导航栏信息，渲染到页面
   - 吸顶 通过 window.onscroll 事件监听滚动距离 弹出一个吸顶的组件（一开始隐藏，距离合适显示即可）； 使用 vueuse 包提供的方法，按需导入方法，实现获取滚动距离。

## 二. 首页模块

### 1.侧边栏

1. 为分类提前定义写死的内容，防止出现调接口时间过长，产生长时间空白
2. 左侧分类动态渲染，根据鼠标移入的单个分类的 id 弹出对应内容的弹出框
3. **骨架屏组件效果优化，提升用户体验**：为网页封装一个骨架屏组件（这个组件出现在数据填充之前，去填充未填充数据的位置，获得数据后，再显示正常数据，使页面效果更好）
   1. 封装一个骨架组件（可以在父组件中动态设置 高度，宽度，背景颜色，是否有动画）
      2. 封装插件，定义一个 js 文件，将骨架组件导入，进行封装全局插件，在 main.js 中引入并且 use
         3. 最后在需要的组件中使用插件即可

### 2.轮播图

1. 封装一个轮播图组件，通过父组件传值来控制自动轮播和轮播时间间隔
2. 轮播图内部封装逻辑：
   1. 接收三个父组件的数据：图片，autoplay（是否自动播放），和 duration（时间）；
   2. 循环渲染图片和索引原点，setup 里定义 index，轮播函数：设置定时器，增加 index 大小，使图片和小圆点按照 index 轮播。通过 watch 监听图片数据是否传入和是否自动播放，来调用轮播函数；
   3. 鼠标进入，开启轮播函数，鼠标离开，清除定时器；
   4. 指示器切换，根据点击的指示器，切换上一张和下一张

### 3.主页各模块渲染

1. 封装通用组件，各个渲染、
2. 添加主页加载图片骨架屏效果，并实现骨架屏切换到真实图片的 vue3 动画过渡效果
   - 使用 vue 的 transition 组件配合过渡类名，实现过渡动画
3. 实现数据的懒加载
   - 使用@vueuse/core 中的 useIntersectionObserver 实现监听进入可视区域的行为（必须配合 vue3 的组合 API 才能实现）
   - 封装公共懒加载函数，将需要懒加载的组件引用这个函数即可

### 4.问题总结

1. 由于精选模块，图片过多，需单独封装懒加载函数，目的：当图片进入可视区域内去加载图片，且处理加载失败，封装成指令

   - 使用原生 webAPI 的 IntersectionObserver 和 vue3 封装懒加载指令：监听图片 dom 元素是否进入可视区域，来完成图片 dom 的 src 属性的赋值

2. 批量自动化注册组件

   - 使用 `require` 提供的函数 `context` 加载某一个目录下的所有 `.vue` 后缀的文件。

     - `const importFn = require.context('./', false, /\.vue$/)`

   - 然后 `context` 函数会返回一个导入函数 `importFn`

     - 它又一个属性 `keys()` 获取所有的文件路径

   - 通过文件路径数组，通过遍历数组，再使用 `importFn` 根据路径导入组件对象

   - 遍历的同时进行全局注册即可

     - // 批量注册全局组件

       `importFn.keys().forEach(key => {`

       `// 导入组件`

       `const component = importFn(key).default`

       `// 注册组件`

       `app.component(component.name, component)`

       `})`

## 三. 商品分类

### 1.使用技术

- vue 底层组件封装
- vuex 数据管理
- router 路由配置
- 通用面包屑组件封装

### 2.实现流程

1. 首页头部分类导航交互
   - 配置路由和组件，根据点击的商品 id 实现一级分类和二级分类路由跳转
   - 创建一级分类组件和二级分类组件，实现成功跳转，并关闭分类弹窗、
2. 实现面包屑导航
   - 独立封装组件，使用 render 函数动态创建模板实现面包屑结构
   - 根据不同级别分类添加不同个数的导航
3. 顶级类目-基础布局搭建： 完成顶级分类的，面包屑+轮播图+所属全部子级分类展示。
   - 准备基础结构，获取轮播图数据给组件使用
   - 获取面包屑和所有分类数据给子级分类展示使用
   - 展示各个子级分类下推荐的商品数据并实现基础布局
4. 顶级类目-分类商品-展示：根据切换路由的时候，根据分类 ID 获取数据，渲染分类商品。
   - 监听地址栏 id 的变化，调用接口获取不同分类数据
   - 实现切换类名后的面包屑切换动画，使用 Transition 组件标签包裹面包屑组件标签
5. 优化路由跳转细节
   - 每次跳转回到页顶：给 router 实例里面添加 scrollBehavior 方法
6. 二级类目-筛选区展示：根据后台返回的筛选条件展示筛选区域。
   - 封装一个组件来展示筛选区域，获取数据进行品牌和属性的渲染
7. 二级类目-复选框组件封装：实现一个自定义复选框组件。
8. 二级类目-结果区-排序组件：封装排序组件，实现用户需求的排序切换效果
9. 二级类目-结果区-数据加载：实现结果区域商品动态展示
   - 实现筛选结果区布局。
   - 实现结果区列表的无限加载组件，使用户上拉可以动态加载数据。
     - 父组件中定义是否加载数据的参数，和是否全部加载完成的参数，通过@vueuse/core 的 useIntersectionObserver 监听该组件是否进入可视区，动态传值给该子组件，调用接口
     - 使用 useIntersectionObserver 监听该组件是否进入可视界面，然后调用接口，获取一页数据。
10. 二级类目-结果区-进行筛选：在做了筛选和排序的时候从新渲染商品列表
    - 根据后端要求，后去筛选区域的筛选条件，后排序区域的排序条件，通过接口发给后端，获得筛选后的数据，并渲染到页面，每次点击筛选和排序都要发送数据调用接口

### 3.问题总结

- 第三方的方法实现父子相互传值
- vue 的 data 中的响应式数据必须提前定义，后续动态添加的不具备（但是可以通过 this.\$set()方法动态添加）

## Project setup

```
npm install
```

### Compiles and hot-reloads for development

```
npm run serve
```

### Compiles and minifies for production

```
npm run build
```

### Lints and fixes files

```
npm run lint
```

### Customize configuration

See [Configuration Reference](https://cli.vuejs.org/config/).
